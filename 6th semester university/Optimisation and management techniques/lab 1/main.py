import numpy


def main_task(A, x, i):
    n = len(A)

    # Шаг 1. Находим ℓ = A(−1)*x. Если ℓi = 0, то матрица _A необратима и метод завершает свою работу;
    # в противном случае матрица _A обратима и мы переходим на следующий шаг
    l = numpy.linalg.solve(numpy.linalg.inv(A), x)
    if l[i] == 0:
        print("\nМатрица _A необратима.")
        return

    # Шаг 2. Формируем вектор ~ℓ, который получается из вектора ℓ заменой i-го элемента на −1
    l2 = numpy.copy(l)
    l2[i] = -1

    # Шаг 3. Находим ˆℓ = −(1/ℓi)*~ℓ
    l3 = -1 / l[i] * l2

    # Шаг 4. Формируем матрицу Q, которая получается из единичной матрицы
    # порядка n заменой i-го столбца на столбец ˆℓ
    Q = numpy.eye(n)
    Q[:, i] = l3

    # Шаг 5. Находим _(A)(−1) = Q*A(−1)
    print("\nМатрица _A обратима, её обратная матрица:")
    print(numpy.dot(Q, numpy.linalg.inv(A)))


##########################################################################################

A = numpy.array([[1, -1, 0],
                 [0, 1, 0],
                 [0, 0, 1]])

x = numpy.array([1, 0, 1])
i = 1

print('\nМатрица 1 (из примера):')
print(A)
print('x:', x)
print('i:', i)
main_task(A, x, i)

################

A = numpy.array([[423, -431, 0],
                 [53, 21, 4],
                 [1, -342, 532]])

x = numpy.array([55, 234, 0])
i = 1

print('\n\n\nМатрица 2:')
print(A)
print('x:', x)
print('i:', i)
main_task(A, x, i)

################

A = numpy.array([[1, 2, 3],
                 [4, 8, 6],
                 [7, 8, 9]])

x = numpy.array([1, 2, 3])
i = 0

print('\n\n\nМатрица 3:')
print(A)
print('x:', x)
print('i:', i)
main_task(A, x, i)
